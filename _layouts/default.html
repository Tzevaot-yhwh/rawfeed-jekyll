<!-- Theme for Jekyll.rb by: © William C. Canin -->
{%- if site.maintenance.enable -%}
  {%- include layout/maintenance.html -%}
{%- else -%}

{%- assign index = site.pages | where: "path", "index.md" | first -%}

<!DOCTYPE html>
<html id="top" lang="{{ site.lang | default: 'en-US' }}" data-theme="light">
  {%- include layout/head.html -%}
  <body data-layout="{{ page.layout | default: '' }}" data-terminal-enabled="{{ site.home.terminal.enable | default: false }}">
    {%- if site.home.terminal.enable and page.url == "/" and index.layout == "home" -%}
      <div class="default default-terminal" style="max-width: {{ site.layout.width | default: '780px' }} !important;">
        {%- include layout/header.html -%}
      </div>
      <main class="content">{{ content }}</main>
      {%- include layout/footer.html -%}
    {%- else -%}
      <div class="default" style="max-width: {{ site.layout.width | default: '780px' }} !important;">
        {%- include layout/header.html -%}
        <main class="content">{{ content }}</main>

        {%- include layout/footer.html -%}
      </div>
    {%- endif -%}
  </body>

  <!-- Scripts -->
  <script src="{{ '/assets/vendor/bootstrap/js/bootstrap.bundle.js' | relative_url }}"></script>

  {%- if page.comments != false and site.blog.post.comments.provider == 'giscus' -%}
  <script>
    window.giscusThemes = {
      light: "{{ site.blog.post.comments.giscus.theme_light | default: 'light' }}",
      dark: "{{ site.blog.post.comments.giscus.theme_dark | default: 'dark' }}"
    };
  </script>
  {%- endif -%}

  <script src="{{ '/assets/js/default.js' | relative_url }}"></script>

  {%- if page.url == '/' and site.home.terminal.enable -%}
    <script src="{{ '/assets/js/terminal.js' | relative_url }}"></script>
  {%- endif -%}

  {%- if site.avatar.open -%}
    <script src="{{ '/assets/js/avatar.js' | relative_url }}"></script>
  {%- endif -%}

  {%- if site.blog.search.enable -%}
    {%- if page.url == '/blog/' or page.url == '/blog/index.html' -%}
      <script src="{{ '/assets/vendor/simple-jekyll-search.min.js' | relative_url }}"></script>
      <script src="{{ '/assets/js/blog_search.js' | relative_url }}"></script>
      <script>
        var sjs = SimpleJekyllSearch({
          searchInput: document.getElementById('blog-search__input'),
          resultsContainer: document.getElementById('blog-search__results'),
          searchResultTemplate: '<li><span class="blog-list__meta"><time datetime="{date}">{date}</time></span>&nbsp;»&nbsp; <a class="blog-list__link" href="{{ site.url }}{url}">{title}</a></li>',
          noResultsText: '<p>{{ site.text.blog.no_results | default: "No results found" }}</p>',
          json: '/assets/json/blog_search.json'
        })
      </script>
    {%- endif -%}
  {%- endif -%}

  {%- if site.home.terminal.enable and page.url == "/" -%}
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const screen = document.getElementById('screen');
      const terminal = document.getElementById("terminal");
      const socialsEl = document.getElementById("terminal-screen--socials");

      const commands = {
        help: `{{ site.text.home.terminal.commands }}`,
        about: document.getElementById("home-content").innerHTML,
        socials: socialsEl ? socialsEl.innerHTML : `{{ site.text.home.terminal.no_socials }}`,
      };

      function createInputLine() {
        const line = document.createElement('div');
        line.className = 'line';

        const prompt = document.createElement('span');
        prompt.className = 'prompt';
        prompt.textContent = `[{{ site.text.home.terminal.user }}@{{ site.text.home.terminal.hostname }}:~]$`;

        // wrapper para conter input, cursor e measure
        const wrapper = document.createElement('span');
        wrapper.className = 'input-wrapper';

        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'input';
        input.placeholder = `{{ site.text.home.terminal.welcome }}`;
        input.spellcheck = false;
        input.autocomplete = 'off';
        input.autocorrect = 'off';
        input.autocapitalize = 'off';

        const cursor = document.createElement('span');
        cursor.className = 'cursor';

        const measure = document.createElement('span');
        measure.className = 'measure';

        wrapper.appendChild(input);
        wrapper.appendChild(cursor);
        wrapper.appendChild(measure);

        line.appendChild(prompt);
        line.appendChild(wrapper);
        screen.appendChild(line);

        input.focus();
        screen.scrollTop = screen.scrollHeight;

        // Updates the fake cursor position based on the input's selectionStart
        function updateCursor() {
          const sel = input.selectionStart || 0;
          // measure the text to the position of the caret
          measure.textContent = input.value.slice(0, sel);
          const textWidth = measure.offsetWidth; // largura do texto sem scroll
          const visibleLeft = textWidth - input.scrollLeft;
          cursor.style.left = visibleLeft + 'px';

          // ensure the caret is visible (for long texts): adjust input's scrollLeft
          const paddingRight = 10;
          if (textWidth - input.scrollLeft > input.clientWidth - paddingRight) {
            input.scrollLeft = textWidth - input.clientWidth + paddingRight;
            cursor.style.left = (textWidth - input.scrollLeft) + 'px';
          } else if (textWidth < input.scrollLeft) {
            input.scrollLeft = textWidth;
            cursor.style.left = (textWidth - input.scrollLeft) + 'px';
          }
        }

        // show/hide cursor animation as focus changes
        function onFocus() { cursor.style.opacity = '1'; updateCursor(); }
        function onBlur()  { cursor.style.opacity = '0'; }

        input.addEventListener('input', updateCursor);
        input.addEventListener('keydown', (e) => {
          // Update position on keys that do not trigger input immediately (arrows, delete, etc.)
          setTimeout(updateCursor, 0);

          if (e.key === 'Enter') {
            e.preventDefault();
            const cmd = input.value.trim().toLowerCase();
            if (cmd) {
              // remove input/cursor/measure and place fixed text
              wrapper.removeChild(input);
              wrapper.removeChild(cursor);
              wrapper.removeChild(measure);
              const cmdText = document.createElement('span');
              cmdText.textContent = cmd;
              wrapper.appendChild(cmdText);
              processCommand(cmd);
            } else {
              // if you enter without command, it just creates a new empty line (with prompt)
              wrapper.removeChild(input);
              wrapper.removeChild(cursor);
              wrapper.removeChild(measure);
              const blank = document.createElement('span');
              blank.textContent = '';
              wrapper.appendChild(blank);
            }
            // New linr input
            createInputLine();
          } else if (e.key === 'Escape') {
            e.preventDefault();
            screen.innerHTML = '';
            createInputLine();
          }
        });

        // arrows, mouse click, mouseup (position caret), etc.
        input.addEventListener('keyup', updateCursor);
        input.addEventListener('click', () => {
          // updates after click (selectionStart already set)
          setTimeout(updateCursor, 0);
        });
        input.addEventListener('mouseup', () => setTimeout(updateCursor, 0));
        input.addEventListener('focus', onFocus);
        input.addEventListener('blur', onBlur);

        updateCursor();
      }

      // processes commands
      function processCommand(cmd) {
        switch(true){
          case cmd === 'help': commandsPrint(commands.help, mode='html'); break;
          case cmd === 'date': commandsPrint(new Date().toString(), mode='text'); break;
          // case cmd.startsWith('echo '): commandsPrint(cmd.split(' ').slice(1).join(' ')); break;
          case cmd === 'about': writeLineHTML(commands.about); break;
          case cmd === 'socials': writeLineHTML(commands.socials); break;
          case cmd === 'clear': screen.innerHTML=''; break;
          default: if(cmd) commandsPrint(cmd + `{{ site.text.home.terminal.error }}`, mode='text');
        }
      }

      function writeLineHTML(content, mode = 'html') {
        const wrapper = document.createElement('div');
        wrapper.className = 'line-wrapper';

        if (mode === 'html') {
          wrapper.innerHTML = content;
        } else {
          wrapper.textContent = content;
        }
        screen.appendChild(wrapper);
        screen.scrollTop = screen.scrollHeight;
      }

      function commandsPrint(text, mode = 'html') {
        // creates the wrapper to group all the lined
        const wrapper = document.createElement('div');
        wrapper.className = 'line-wrapper';

        text.split('\n').forEach((t) => {
          const line = document.createElement('div');
          line.className = 'line';
          if (mode === 'html') {
            line.innerHTML = t;
          } else {
            line.textContent = t;
          }
          wrapper.appendChild(line);
        });

        screen.appendChild(wrapper);
        screen.scrollTop = screen.scrollHeight;
      }

      // start terminal
      createInputLine();

      // when clicking on the terminal, it always focuses on the last existing input
      terminal.addEventListener("click", (e) => {
        // avoids focusing when clicking a header button, etc.
        const lastInput = screen.querySelector('.input:last-of-type');
        if (lastInput) lastInput.focus();
      });
    });
  </script>
  {%- endif -%}
</html>
{%- endif -%}
